# Как работает CSRF?
Чтобы CSRF стала возможной, необходимо наличие трех ключевых условий:
- Соответствующее действие. В приложении есть действие, которое злоумышленник имеет основания вызвать. Это может быть привилегированное действие (например, изменение разрешений для других пользователей) или любое действие над данными конкретного пользователя (например, изменение собственного пароля).
- Обработка сеанса на основе куки. Выполнение действия подразумевает выдачу одного или нескольких HTTP-запросов, и приложение полагается исключительно на куки сеанса для идентификации пользователя, выполнившего эти запросы. Нет никаких других механизмов для отслеживания сеансов или проверки запросов пользователя.
- Отсутствие непредсказуемых параметров запроса. Запросы, выполняющие действие, не содержат параметров, значения которых злоумышленник не может определить или угадать. Например, заставляя пользователя сменить пароль, функция не уязвима, если злоумышленнику необходимо знать значение существующего пароля.

Примечание:
>Хотя CSRF обычно описывается в связи с обработкой сеанса на основе cookie, он также возникает в других контекстах, когда приложение автоматически добавляет некоторые учетные данные пользователя к запросам, например, при аутентификации HTTP Basic и аутентификации на основе сертификатов.

Например, приложение содержит функцию, позволяющую пользователю изменить адрес электронной почты в своей учетной записи:

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```
  
Можно создать страницу, содержащую следующий HTML:

```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script> document.forms[0].submit(); </script>
    </body>
</html>
```

Если пользователь созданную страницу, произойдет следующее:
- Страница вызовет HTTP-запрос на уязвимый веб-сайт.
- Если пользователь вошел на уязвимый сайт, его браузер автоматически включит в запрос сессионный файл cookie (при условии, что не используются SameSite cookie).
- Уязвимый веб-сайт обработает запрос обычным образом, расценит его как сделанный пользователем-жертвой и изменит его адрес электронной почты.

# Общие меры защиты от CSRF
## CSRF токены
CSRF-токен - это уникальное, секретное и непредсказуемое значение, которое генерируется приложением на стороне сервера и передается клиенту. При отправке запроса на выполнение сенситив действия, такого как отправка формы, клиент должен указать правильный маркер CSRF. В противном случае сервер откажется выполнять запрошенное действие.

Распространенным способом передачи CSRF-токенов клиенту является включение их в качестве скрытого параметра в HTML-форму, например:

```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
	<label>Email</label>
	<input required type="email" name="email" value="example@normal-website.com">
	<input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
	<button class='button' type='submit'> Update email </button>
</form>
```

Отправка этой формы приводит к следующему запросу:

```http
POST /my-account/change-email HTTP/1.1
Host: normal-website.com
Content-Length: 70
Content-Type: application/x-www-form-urlencoded

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com
```

### Общие недостатки при валидации CSRF токенов
#### Валидация CSRF-токена зависит от метода запроса
Некоторые приложения правильно проверяют маркер, когда запрос использует метод POST, но пропускают проверку, когда используется метод GET. В этой ситуации можно переключиться на метод GET, чтобы обойти валидацию:

```http
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```

#### Проверка CSRF токена зависит от наличия токена
Некоторые приложения правильно проверяют маркер, если он присутствует, но пропускают проверку, если маркер пропущен. В этой ситуации можно удалить весь параметр, содержащий токен (а не только его значение), чтобы обойти проверку:

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

email=pwned@evil-user.net
```

## SameSite cookie


## Refer-based валидация

